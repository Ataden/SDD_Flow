# Technical Design Document Template

*Project: [Project Name]*  
*Feature/Module: [Feature Name]*  
*Version: [Version Number]*  
*Date: [Date]*  
---

## Document Overview

**Purpose:** [Describe what this document achieves - typically defines technical implementation approach, component architecture, and data structures for the feature]

**Target Audience:** [Who will use this document - typically development team, AI coding agents, technical reviewers, and future maintainers]

**Prerequisites:** [What documents or knowledge are required before reading this - typically System Architecture Document, Functional Design Document, and Technology Stack familiarity]

---

## 1. Overview
<overview>
### 1.1 Feature Summary
*Notes: Provide a brief 2-3 sentence description of what this feature does from a technical perspective. Focus on the core technical capability, not business value.*

**Example:**
```
The Thread Hierarchy Manager implements expandable/collapsible message threading for Telegram chat visualization, providing React components that consume FastAPI endpoints to render nested comment structures with independent branch state management.
```

### 1.2 Technical Approach
*Notes: Outline the high-level technical strategy and key architectural decisions. Include the main patterns, technologies, and approaches that will be used.*

**Example:**
```
- Architecture Pattern: Component-based frontend with stateful expansion tracking
- Data Strategy: Pre-computed thread relationships stored in normalized database schema
- State Management: React hooks with local storage persistence for expansion states
- Performance Strategy: Lazy loading with virtual scrolling for large thread hierarchies
- all onther key details...
```

### 1.3 Scope & Dependencies
*Notes: Define what's included in this feature, what's explicitly excluded, and what other components or systems this feature depends on.*

**Example:**
```
Included:
- Thread expansion/collapse UI components
- Branch state management system
- Thread hierarchy API endpoints

Excluded:
- Real-time updates (deferred to Phase 2)
- User authentication integration

Dependencies:
- Chat data ingestion system (already implemented)
- Message database schema (already implemented)
- React routing system (already implemented)
```

</overview>

## 2. Component Architecture
<component_architecture>
### 2.1 Reference Tables

#### 2.1.1 Component Reference Table
<component_reference_table>
Example:
```markdown
| ID | Component Name | Layer | Description |
|----|----------------|-------|-------------|
| F1 | ThreadViewer | Frontend | Thread viewer component |
| F2 | ExpansionStateManager | Frontend | Expansion state manager component |
| B1 | ThreadService | Backend | Thread service component |
| D1 | Database | Data | Database component |
```
</component_reference_table>
*Note: Consistently numerate the conponents with IDs. For frontend components - F1 (F1.ThreadViewer), F2, etc. For backend - B1, B2, etc For data - D1, etc. And use the same numeration in the rest of the document.*

#### 2.1.2 Component Interactions Reference Table
<component_interactions_reference_table>
Example:
```markdown
| Interaction ID | Components | Description |
|----|-------------|-------------|
| I1  | F1->B1->B2      | JWT authentication and token management |
```
</component_interactions_reference_table>

### 2.1 Component Overview Diagram
*Notes: 
- Create a Mermaid diagram showing the high-level components and their relationships. Include frontend, backend, data layer, etc. components with their interactions. 
- All components ani interactions must be always shown with their IDs.*

<component_overview_diagram>
**Example:**

```mermaid
graph TD
    subgraph "Frontend Layer"
        UI[F1.ThreadViewer Component]
        STATE[F2.ExpansionStateManager]
        CACHE[F3.ThreadCache]
    end
    
    subgraph "API Layer"
        ROUTER[B1.FastAPI Router]
        SERVICE[B2.ThreadService]
        VALIDATOR[B3.RequestValidator]
    end
    
    subgraph "Data Layer"
        DB[D1.Database]
        QUERY[D2.ThreadQueryBuilder]
    end
    
    UI -->|I1| STATE
    UI -->|I2| CACHE
    STATE -->|I3| ROUTER
    ROUTER -->|I4| VALIDATOR
    VALIDATOR -->|I5| SERVICE
    SERVICE -->|I6| QUERY
    QUERY --> DB
    
    STATE -.-> STORAGE[LocalStorage]
```

</component_overview_diagram>

### 2.2 Component Specifications

<component_specifications>
For each layer of the application (frontend components, frontend services, backend services, data layer, etc.) provide the following:
#### 2.2.1 [Component Layer Name - e.g., Frontend Components]
*Notes: For each major component, provide its purpose, key responsibilities, and important interfaces (not internal methods). Include enough detail for developers and AI coding agents to understand how to implement it.*


**[Component ID][Component Name]**
- **Purpose:** [Single sentence describing what this component does]
- **Implementation Details (optional):** [Implementation details]
- **Responsibilities/Features:** [Bullet list of key responsibilities/features]

Additionaly for frontend components:
- **External Inputs (Props):** [ List of external inputs (props) ]
- **Events/Callbacks (Props):** [ List of events/callbacks (props) ]
- **Internal State:** [ List of internal state and brief description of each]


#### 2.2.2 [Another Component Layer - e.g., Backend Services]
*Notes: Repeat the same structure for backend services, data access layers, etc.*
</component_specifications>

### 2.3 Component Interaction Flow
*Notes: Create a Mermaid sequence diagram(S) showing how the components interact for a typical user action. This helps developers understand the data flow.*

<component_interaction_flow>
**Example:**
```mermaid
sequenceDiagram
    participant User
    participant F1[F1.ThreadViewer]
    participant F2[F2.ExpansionStateManager]
    participant B1[B1.ThreadService]
    participant D1[D1.Database]
    
    User->>F1: Click expand on message
    F1->>F2: updateExpansionState(messageId, true)
    F2->>F2: Update local state
    F2->>localStorage: Persist state
    F1->>B1: GET /api/messages/{id}/children
    B1->>D1: Execute thread query
    D1-->>B1: Return child messages
    B1-->>F1: MessageList response
    F1->>F1: Render expanded thread
    F1-->>User: Display nested messages
```

**Data flow notes:**
*Notes: Provide any additional notes or remarks about the data flow.*

</component_interaction_flow>

### 2.4 UI Component Tree 
*A tree of actual UI components in ascii format. If a UI prototype is provided, include a tree of actual UI components *

<ui_component_tree>
Example:
```
F1. Dashboard App (app/page.tsx)
├── LoginView (components/login-view.tsx)
│   ├── Card
```

</ui_component_tree>

---

## 3. Data Models & Schemas

### 3.1 Data Contracts (DCs)
*Notes: Define the exact structure of data that flows between components (see 2. Component Architecture). Include both request and response models. All data contracts are language-agnostic and describe the structure of data exchanged between client and server, independent of implementation language or DTO conventions.*

<data_contracts>
#### 3.1.1 <Interaction ID> : <Component1.ID.Component1 Name> -> <Component2.ID Component2.Name>
*Notes: 
- Define the structure of data sent TO your APIs and received FROM your APIs, including all protocols (REST, WebSockets, etc) and types (errors, etc)
- if request DC is empty, then create it anyway, but mark it as empty*

- **Request:** <DC_ID.DC Name> (Component1.ID → Component2.ID)
  - field1:type
  - field2:type

- **Response:** <DC_ID.DC Name> (Component2.ID → Component1.ID)
  - field1:type
  - field2:type

**Example:**
```
##### I1 : <F1.Dashboard App> -> <B2.Auth Service>

- **Request:** <DC1-1.LoginRequest> (F1 → B2)
  - username: string
  - password: string
- **Response:** <DC1-2.LoginResponse> (B2 → F1)
  - access_token: string
  - token_type: string (always "bearer")
  - expires_in: integer (seconds)
```

</data_contracts>

### 3.2 Internal Component Models
*Notes: Define data structures used internally within components - React state, service layer objects, etc. These don't cross API boundaries but are important for implementation. IMPORTANT: This is section is skipped in the initial design and should be added as documenting the actual implementation!*

<component_models>
#### <Component> State Models
*Notes: For each major component type, define its internal data structures - interfaces, dataclasses, etc*

</component_models>

### 3.3 Persistence Model (Database Schema)
*Notes: Define the database schema including tables, relationships, and important indexes. Include migration scripts if schema changes are needed.*

<persistence_model>

#### DB Entity Relationship Diagram
*Notes: Create a Mermaid ERD showing tables and relationships*
<entity_relationship_diagram>
**Example:**
```mermaid
erDiagram
    Chat ||--o{ Message : contains
    Message ||--o{ Message : "replies_to"
    Message ||--|| Thread : "belongs_to"
    
    Chat {
        bigint id PK
        string name
        string username
        string invite_link
        timestamp created_at
        int message_count
    }
    
    Message {
        int id PK
        string text
        string user
        bigint user_id
        timestamp date
        bigint chat_id FK
        int reply_to_id FK
        int thread_id FK
        int depth
        jsonb metadata
        timestamp created_at
        timestamp updated_at
    }
```
</entity_relationship_diagram>
#### Database Migrations
*Notes: Include any DDL statements needed to implement or modify the schema: tables and constraints. But omit indexes.*

<migrations>
**Example:**
```sql
-- Migration: Add thread performance indexes
CREATE TABLE IF NOT EXISTS messages (
    id SERIAL PRIMARY KEY,
    text TEXT NOT NULL,
    user VARCHAR(255) NOT NULL,
    user_id BIGINT NOT NULL,
    chat_id BIGINT NOT NULL,
    reply_to_id BIGINT,
    thread_id BIGINT NOT NULL,
    depth INT NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```
</migrations>

## 4. API Endpoints
<api_endpoints>
### 4.1 Internal APIs
*Notes: Define all API endpoints that are part of this feature. Include HTTP methods, URLs, parameters, request/response bodies - as reference to the DCs in the Data Models & Schemas section, and error codes. Use OpenAPI format or similar structured approach. 

IMPORTANT: If a parameter is in the DC, do not repeat it in the API endpoint route, use post method instead with body parameters. And reference the respective DC*

<internal_apis>

#### [API Group Name - e.g., Thread Management Endpoints] (Component1.ID -> Component2.ID)
*Notes: For each logical group of endpoints, provide detailed specifications. IMPORTANT: Reference to the DCs in the Data Models & Schemas section, do not expand the DCs*

**Example:**
```yaml
# OpenAPI specification format
/api/chats/{chat_id}/roots:
  get:
    summary: Get root messages for a chat
    parameters:
      - name: chat_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        content:
          application/json:
            schema:
              type: object
              properties:
                messages:
                  type: array
                  items:
                    $ref: '#/components/schemas/MessageResponse' (DC2-1.MessageResponse)
```
</internal_apis>

### 4.2 Interface Contract Summary
*Notes: This table provides a high-level overview of the interface contracts between the UI and backend components. It includes the UI feature, the corresponding API endpoint, and any additional notes or remarks.*

<interface_contract_summary>
| UI Feature | Endpoint | DC IDs | Notes |
| --- | --- | --- | --- |

</interface_contract_summary>

</api_endpoints>

### 4.3 External APIs & Integrations
*Notes: Define any external APIs that this feature calls, or any APIs that this feature exposes to external systems. Include authentication, rate limiting, and error handling details.*

<external_apis>

#### [Integration Name - e.g., Third-party Service Contracts]
*Notes: For each external integration, define the contract and implementation approach, including SDKs and docs references*

**Documentation and SDK:**
*Notes: Provide links to relevant documentation and SDKs*

**Connection Details:**
*Notes: Provide connection details, including endpoint, authentication, protocol, used by, model, etc*

**Example:**

```markdown
#### E1. OpenAI Realtime API Integration

**Documentation and SDK:**
- https://platform.openai.com/docs/api-reference/realtime
- https://github.com/openai/openai-python?tab=readme-ov-file#realtime-api-beta

**Connection Details:**
- **Endpoint:** wss://api.openai.com/v1/realtime
- **Authentication:** Bearer token in headers
- **Protocol:** WebSocket with JSON/binary messages
- **Used by:** B4 (Voice Service)
- **Model:** gpt-4o-mini
```

</external_apis>

## 5. Deployment Architecture

<deployment_architecture>

### 5.1 Container Architecture
*Notes: Describe the container architecture for this feature*

**Example:**
```mermaid
graph TB
    subgraph "Docker Compose"
        Frontend["Frontend Container<br/>React.js + nginx"]
        Backend["Backend Container<br/>FastAPI + uvicorn"]
        Database["Database<br/>SQLite file (Light)<br/>PostgreSQL (Full)"]
        
        Frontend --> Backend
        Backend --> Database
    end
    
    User["User"] --> Frontend
    Admin["Admin"] --> Backend
```

### 5.2 Deployment Strategy
*Notes: Describe the deployment strategy for this feature. Containers, ports, volumes, etc*

Example:
- **Frontend**: React.js built assets served via nginx, port 80
- **Backend**: FastAPI with uvicorn ASGI server, port 8000
- **Database**: SQLite file mounted as volume in Backend container
- **Environment**: Single-server deployment with docker with compose plugin

**Deployment Command:**
```bash
# Using docker with compose plugin (not docker-compose)
docker compose up -d
```

</deployment_architecture>

## 6. Performance and Monitoring

<performance_and_monitoring>

**Performance Configuration:**
*Notes: Describe the performance configuration for this feature*

**Monitoring Setup (Basic Metrics):**
[yaml config]

**Key Metrics:**
Example:
- `voice_sessions_active`: Current active voice sessions in B4 (max 1)
- `call_duration_seconds`: Histogram of call durations from B5

</performance_and_monitoring>

## 7. Feature-Specific Security Assessment (optional)

*Notes: This section is optional but recommended for features that handle sensitive data or expose new attack surfaces. Identify and mitigate security risks introduced by this feature.*

<security_assessment>
### 7.1 Security Considerations
*Notes: Identify potential security risks and how they will be mitigated*

#### [Security Area - e.g., Input Validation]
*Notes: For each security concern, define the risk and mitigation approach*


#### [Security Area - e.g., Rate Limiting]
*Notes: Define rate limiting and abuse prevention measures*

### 7.2 Data Privacy
*Notes: Define how this feature handles sensitive data and privacy requirements*

**Example:**
```
- PII Handling: Message content treated as sensitive data
- Access Control: Thread access inherits chat permissions
- Audit Logging: Log thread access patterns for security monitoring
```

</security_assessment>

## Appendices
